<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, viewport-fit=cover" />
  <meta name="theme-color" content="#000000" />
  <title>CONSIA ‚àû</title>

  <!-- Opcional (si ya ten√©s estos archivos en el repo) -->
  <link rel="manifest" href="./manifest.webmanifest" />
  <link rel="icon" href="./icon-192.png" />
  <link rel="apple-touch-icon" href="./icon-192.png" />

  <style>
    :root{
      --bg:#000;
      --txt:#fff;
      --muted: rgba(255,255,255,.72);
      --muted2: rgba(255,255,255,.55);
      --glass: rgba(10,10,14,.55);
      --glass2: rgba(10,10,14,.78);
      --stroke: rgba(255,255,255,.16);
      --stroke2: rgba(255,255,255,.10);
      --ok:#2ee59d;
      --warn:#ffcc66;
      --bad:#ff5f6d;
      --chip: rgba(255,255,255,.06);
      --chip2: rgba(255,255,255,.10);
      --shadow: 0 20px 60px rgba(0,0,0,.6);
      --r: 18px;

      /* C√°mara: ajust√° si quer√©s */
      --camW: 360px;
      --camH: 240px;
    }

    *{ box-sizing:border-box; }
    html,body{ height:100%; margin:0; background:var(--bg); color:var(--txt); font-family: -apple-system, BlinkMacSystemFont, "SF Pro Display", "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
    body{ overflow:hidden; }

    /* FULLSCREEN AVATAR */
    .stage{
      position:fixed; inset:0;
      width:100vw; height:100vh;
      background:#000;
      overflow:hidden;
    }

    /* video ocupa TODA la pantalla, centrado, sin cortes raros */
    video#avatarBase{
      position:absolute; inset:0;
      width:100%;
      height:100%;
      object-fit: cover;
      object-position: center center;
      transform: translateZ(0);
      opacity:1;
      filter: saturate(1.05) contrast(1.05);
    }

    /* capa ‚Äúhalo‚Äù cuando CONSIA habla */
    .speakHalo{
      position:absolute; inset:-20px;
      pointer-events:none;
      opacity:0;
      transition: opacity .25s ease;
      background: radial-gradient(circle at 50% 55%, rgba(255,255,255,.18), transparent 55%),
                  radial-gradient(circle at 50% 55%, rgba(46,229,157,.15), transparent 62%);
      mix-blend-mode: screen;
      filter: blur(1px);
    }
    .speaking .speakHalo{ opacity:1; }

    /* HUD */
    .hud{
      position:absolute; inset:0;
      display:flex;
      flex-direction:column;
      justify-content:flex-end;
      gap:12px;
      padding: max(18px, env(safe-area-inset-top)) max(18px, env(safe-area-inset-right)) max(18px, env(safe-area-inset-bottom)) max(18px, env(safe-area-inset-left));
      pointer-events:none;
    }

    .topbar{
      position:absolute;
      left:max(18px, env(safe-area-inset-left));
      right:max(18px, env(safe-area-inset-right));
      top:max(14px, env(safe-area-inset-top));
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      pointer-events:auto;
    }

    .brand{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(10,10,14,.55), rgba(10,10,14,.35));
      border:1px solid var(--stroke2);
      border-radius:999px;
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
    }
    .dot{ width:10px; height:10px; border-radius:50%; background: var(--ok); box-shadow: 0 0 18px rgba(46,229,157,.65); }
    .brand b{ letter-spacing:.6px; }
    .brand small{ color:var(--muted2); margin-left:6px; }

    .status{
      display:flex; align-items:center; gap:10px;
      padding:10px 12px;
      background: linear-gradient(180deg, rgba(10,10,14,.55), rgba(10,10,14,.35));
      border:1px solid var(--stroke2);
      border-radius:999px;
      backdrop-filter: blur(10px);
      box-shadow: var(--shadow);
      color:var(--muted);
      font-size:13px;
      white-space:nowrap;
    }
    .pill{
      padding:4px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.06);
      border:1px solid rgba(255,255,255,.10);
      color:var(--muted);
      font-size:12px;
    }
    .rtOk{ color:var(--ok); }
    .rtBad{ color:var(--bad); }

    .testBtn{
      pointer-events:auto;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:var(--txt);
      border-radius:999px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:600;
      backdrop-filter: blur(10px);
    }

    /* intro card */
    .introCard{
      position:absolute;
      left:50%;
      top:52%;
      transform: translate(-50%,-50%);
      width:min(860px, calc(100vw - 36px));
      background: linear-gradient(180deg, rgba(10,10,14,.55), rgba(10,10,14,.32));
      border:1px solid var(--stroke2);
      border-radius: var(--r);
      backdrop-filter: blur(14px);
      box-shadow: var(--shadow);
      padding:16px;
      pointer-events:auto;
    }
    .introRow{ display:flex; gap:12px; align-items:center; justify-content:space-between; }
    .introTitle{ display:flex; flex-direction:column; gap:4px; }
    .introTitle b{ font-size:14px; letter-spacing:.4px; }
    .introTitle span{ color:var(--muted); font-size:13px; line-height:1.35; }

    .introBtns{ display:flex; gap:10px; align-items:center; }
    .btn{
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color:var(--txt);
      border-radius:999px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:700;
      backdrop-filter: blur(10px);
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
    }
    .btn.primary{
      background: rgba(46,229,157,.16);
      border-color: rgba(46,229,157,.35);
    }
    .btn.warn{
      background: rgba(255,204,102,.14);
      border-color: rgba(255,204,102,.35);
    }

    /* acci√≥n chips */
    .chips{
      width:100%;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
      pointer-events:auto;
      margin-top:10px;
      justify-content:flex-start;
    }
    .chip{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color:var(--txt);
      border-radius:999px;
      padding:10px 12px;
      cursor:pointer;
      font-weight:650;
      backdrop-filter: blur(10px);
      display:inline-flex;
      align-items:center;
      gap:8px;
      user-select:none;
    }
    .chip:hover{ background: rgba(255,255,255,.09); }
    .chip.small{ padding:9px 11px; font-weight:650; }
    .chip.on{ outline:2px solid rgba(46,229,157,.35); background: rgba(46,229,157,.10); }

    /* consola/chat */
    .consoleWrap{
      width:100%;
      max-width: 1080px;
      margin:0 auto;
      pointer-events:auto;
    }

    .console{
      width:100%;
      height: min(44vh, 420px);
      background: linear-gradient(180deg, rgba(10,10,14,.62), rgba(10,10,14,.42));
      border:1px solid rgba(255,255,255,.12);
      border-radius: var(--r);
      backdrop-filter: blur(12px);
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }

    .log{
      flex:1;
      overflow:auto;
      padding:14px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .row{ display:flex; gap:10px; align-items:flex-start; }
    .tag{
      min-width:46px;
      padding:6px 10px;
      border-radius:999px;
      font-size:12px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.05);
      color: var(--muted);
      text-align:center;
      user-select:none;
    }
    .tag.sys{ color: rgba(255,255,255,.75); }
    .tag.you{ color: rgba(125,170,255,.95); border-color: rgba(125,170,255,.22); background: rgba(125,170,255,.08); }
    .tag.ai{ color: rgba(46,229,157,.95); border-color: rgba(46,229,157,.22); background: rgba(46,229,157,.08); }

    .bubble{
      flex:1;
      padding:12px 12px;
      border-radius: 14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      color: rgba(255,255,255,.92);
      line-height:1.4;
      white-space:pre-wrap;
      word-break:break-word;
    }
    .bubble.ai{ background: rgba(46,229,157,.06); border-color: rgba(46,229,157,.18); }
    .bubble.you{ background: rgba(125,170,255,.06); border-color: rgba(125,170,255,.18); }

    .inputBar{
      display:flex;
      gap:10px;
      padding:12px;
      border-top:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      align-items:flex-end;
    }
    textarea{
      flex:1;
      resize:none;
      min-height:46px;
      max-height:160px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.35);
      color: var(--txt);
      padding:12px 12px;
      outline:none;
      font-size:15px;
      line-height:1.35;
    }
    .send{
      min-width:110px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: var(--txt);
      font-weight:800;
      cursor:pointer;
      padding:12px 14px;
    }
    .send:active{ transform: translateY(1px); }

    .metaLine{
      margin-top:10px;
      color: rgba(255,255,255,.70);
      font-size:13px;
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      align-items:center;
      justify-content:flex-start;
    }

    /* C√°mara preview */
    .camBox{
      position:absolute;
      right:max(18px, env(safe-area-inset-right));
      bottom: calc(max(18px, env(safe-area-inset-bottom)) + 220px);
      width: min(var(--camW), calc(100vw - 36px));
      height: min(var(--camH), 36vh);
      border-radius: 18px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,.16);
      background: rgba(0,0,0,.55);
      backdrop-filter: blur(12px);
      box-shadow: var(--shadow);
      display:none;
      pointer-events:auto;
    }
    .camBox.on{ display:block; }
    video#camPreview{
      width:100%; height:100%;
      object-fit: cover;
      transform: scaleX(-1); /* espejo frontal */
    }
    .camBadge{
      position:absolute;
      left:10px; top:10px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(0,0,0,.50);
      border:1px solid rgba(255,255,255,.12);
      font-size:12px;
      color: rgba(255,255,255,.85);
    }

    /* Mobile: consola un poco m√°s baja */
    @media (max-width: 720px){
      .console{ height: min(52vh, 520px); }
      .send{ min-width: 92px; }
    }

    /* reduce motion */
    @media (prefers-reduced-motion: reduce){
      .speakHalo{ transition:none; }
    }
  </style>
</head>

<body>
  <div class="stage" id="stage">
    <!-- AVATAR VIDEO: pon√© avatar.mp4 en la ra√≠z del repo -->
    <video
      id="avatarBase"
      src="./avatar.mp4"
      autoplay
      muted
      playsinline
      loop
      preload="auto"
    ></video>

    <div class="speakHalo"></div>

    <!-- TOP BAR -->
    <div class="topbar">
      <div class="brand">
        <span class="dot" id="onlineDot"></span>
        <b>CONSIA</b><small>‚àû</small>
      </div>

      <div style="display:flex; gap:10px; align-items:center;">
        <div class="status" id="statusPill">
          <span class="pill">Realtime</span>
          <span id="rtText" class="rtBad">desconectado</span>
          <span class="pill">API</span>
          <span id="apiHost">api.consia.world</span>
        </div>
        <button class="testBtn" id="btnTestApi">Test API</button>
      </div>
    </div>

    <!-- Intro: se puede cerrar con ‚ÄúEntrar‚Äù -->
    <div class="introCard" id="introCard">
      <div class="introRow">
        <div class="introTitle">
          <b>Dec√≠ ‚ÄúHola CONSIA‚Äù o toc√° ‚ÄúHablar‚Äù.</b>
          <span>CONSIA puede analizar texto/voz/archivos/c√°mara. Owner-Only: solo vos pod√©s mejorar/crear desde la interfaz.</span>
        </div>
        <div class="introBtns">
          <button class="btn warn" id="btnIntroExplain">‚ñ∂Ô∏é Explicame</button>
          <button class="btn primary" id="btnIntroEnter">Entrar</button>
        </div>
      </div>

      <div class="chips" style="margin-top:12px;">
        <div class="chip" id="chipGuide">üß≠ Guiame (3 opciones)</div>
        <div class="chip" id="chipWhatCan">üß† ¬øQu√© puede hacer?</div>
        <div class="chip" id="chipHyper">üñºÔ∏è Hiperrealismo</div>
        <div class="chip" id="chipVoice">üéôÔ∏è Voz</div>
        <div class="chip" id="chipCam">üì∑ C√°mara</div>
        <div class="chip" id="chipAscend">‚ö° ASCEND</div>
      </div>

      <div class="metaLine" style="margin-top:12px;">
        <span>ONLINE: <b id="onlineText">auto</b></span>
        <span>Idioma: <b>ES</b></span>
        <span>Tip: toc√° cualquier lugar para habilitar audio en iOS.</span>
      </div>
    </div>

    <!-- C√°mara preview -->
    <div class="camBox" id="camBox">
      <div class="camBadge" id="camBadge">C√°mara frontal: ON</div>
      <video id="camPreview" autoplay muted playsinline></video>
    </div>

    <!-- HUD: consola + input -->
    <div class="hud">
      <div class="consoleWrap">
        <div class="chips" style="margin-bottom:10px;">
          <label class="chip small" for="filePick" id="chipUpload">üìé Subir archivo</label>
          <input id="filePick" type="file" multiple style="display:none" />
          <div class="chip small" id="chipCamLive">üìπ C√°mara (vivo 100%)</div>
          <div class="chip small" id="chipTalk">üó£Ô∏è Hablar</div>
          <div class="chip small" id="chipRead">üëÅÔ∏è Leer</div>
          <div class="chip small" id="chipClear">üßπ Limpiar</div>
          <div class="chip small" id="chipStopVoice">‚õî Stop voz</div>
          <div class="chip small" id="chipOwner">üîí Owner</div>
        </div>

        <div class="metaLine">
          <span>Idioma: <b>ES</b></span>
          <span>Realtime: <b id="rtMode">auto</b></span>
          <span>Adjuntos: <b id="attCount">0</b></span>
          <span>C√°mara: <b id="camState">off</b></span>
        </div>

        <div class="console">
          <div class="log" id="log"></div>

          <div class="inputBar">
            <textarea id="msg" placeholder='Dec√≠ lo que quer√©s (o escrib√≠ ".")'></textarea>
            <button class="send" id="sendBtn">Enviar</button>
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    /*********************
     * CONFIG
     *********************/
    const API_ASK = "https://api.consia.world/ask";          // backend principal
    const API_HEALTH = "https://api.consia.world/health";    // health
    const API_AVATAR_TRANSFORM = "https://api.consia.world/avatar/transform"; // owner-only
    const API_AVATAR_LATEST = "https://api.consia.world/avatar/latest";       // estado avatar

    // Realtime (si tu backend lo soporta). Si no, queda ‚Äúdesconectado‚Äù sin romper nada.
    const RT_WS = "wss://api.consia.world/realtime";

    const CONSIA_RULES = [
      "Identidad innegociable: CONSIA.",
      "Ir al grano. Pedir 1 sola cosa m√≠nima. Ejecutar.",
      "Owner-Only: cambios/mejoras solo con token Owner.",
      "Privacy-first. Fail-closed. Sin biometr√≠a real guardada."
    ].join(" | ");

    /*********************
     * STATE
     *********************/
    const el = (id)=>document.getElementById(id);
    const logEl = el("log");
    const msgEl = el("msg");
    const stage = el("stage");
    const introCard = el("introCard");

    let attachments = []; // {name,type,size,dataUrl?}
    let ownerToken = localStorage.getItem("CONSIA_OWNER_TOKEN") || "";
    let speechOn = true;
    let recognizer = null;
    let listening = false;

    let camStream = null;
    let camOn = false;
    let camTimer = null;
    let lastCamFrame = null; // dataURL jpeg

    let rt = { ws: null, connected: false };

    /*********************
     * UI LOG
     *********************/
    function addRow(tag, text, cls=""){
      const row = document.createElement("div");
      row.className = "row";
      const t = document.createElement("div");
      t.className = "tag " + tag;
      t.textContent = tag.toUpperCase();
      const b = document.createElement("div");
      b.className = "bubble " + cls;
      b.textContent = text;
      row.appendChild(t); row.appendChild(b);
      logEl.appendChild(row);
      logEl.scrollTop = logEl.scrollHeight;
    }

    function sys(text){ addRow("sys", text, ""); }
    function you(text){ addRow("you", text, "you"); }
    function ai(text){ addRow("ai", text, "ai"); }

    sys("CONSIA UI HOTFIX activo. Input siempre visible. Idioma ES.");

    /*********************
     * AVATAR ‚ÄúSPEAK‚Äù FX
     *********************/
    function setSpeaking(on){
      if(on) stage.classList.add("speaking");
      else stage.classList.remove("speaking");
    }

    /*********************
     * SPEECH (TTS)
     *********************/
    function speak(text){
      if(!speechOn) return;
      if(!("speechSynthesis" in window)) return;

      // iOS: solo despu√©s de interacci√≥n
      try { window.speechSynthesis.cancel(); } catch(e){}

      const u = new SpeechSynthesisUtterance(text);
      u.lang = "es-ES";
      u.rate = 1.02;
      u.pitch = 1.0;

      u.onstart = ()=>setSpeaking(true);
      u.onend = ()=>setSpeaking(false);
      u.onerror = ()=>setSpeaking(false);

      window.speechSynthesis.speak(u);
    }

    function stopSpeak(){
      try { window.speechSynthesis.cancel(); } catch(e){}
      setSpeaking(false);
    }

    /*********************
     * VOICE INPUT (ASR)
     *********************/
    function setupRecognizer(){
      const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
      if(!SR) return null;
      const r = new SR();
      r.lang = "es-ES";
      r.interimResults = false;
      r.continuous = false;

      r.onstart = ()=>{ listening = true; el("chipTalk").classList.add("on"); };
      r.onend = ()=>{ listening = false; el("chipTalk").classList.remove("on"); };
      r.onerror = ()=>{ listening = false; el("chipTalk").classList.remove("on"); };

      r.onresult = (ev)=>{
        const text = (ev.results?.[0]?.[0]?.transcript || "").trim();
        if(text){
          msgEl.value = text;
          sendNow();
        }
      };
      return r;
    }

    function toggleListen(){
      if(!recognizer) recognizer = setupRecognizer();
      if(!recognizer){
        sys("Voz: tu navegador no soporta SpeechRecognition.");
        return;
      }
      // en iOS/Safari suele requerir gesto
      try{
        if(listening) recognizer.stop();
        else recognizer.start();
      }catch(e){
        sys("Voz: no se pudo iniciar. Prob√° tocar de nuevo.");
      }
    }

    /*********************
     * CAMERA (FRONTAL)
     *********************/
    async function startCamera(){
      if(camOn) return;
      try{
        camStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: "user" }, // FRONTAL
          audio: false
        });

        const v = el("camPreview");
        v.srcObject = camStream;
        el("camBox").classList.add("on");
        camOn = true;
        el("camState").textContent = "on";

        // Captura ‚Äúvivo‚Äù (throttle) ‚Äî etiqueta 100% pero cuidamos performance
        // Pod√©s subir fps si tu backend aguanta.
        camTimer = setInterval(()=>captureFrame(), 900); // ~1.1 fps
        captureFrame();
      }catch(e){
        sys("C√°mara: permiso denegado o no disponible.");
        camOn = false;
        el("camState").textContent = "off";
      }
    }

    function stopCamera(){
      if(camTimer){ clearInterval(camTimer); camTimer = null; }
      if(camStream){
        camStream.getTracks().forEach(t=>t.stop());
        camStream = null;
      }
      camOn = false;
      lastCamFrame = null;
      el("camBox").classList.remove("on");
      el("camState").textContent = "off";
    }

    function captureFrame(){
      if(!camOn) return;
      const v = el("camPreview");
      if(!v.videoWidth || !v.videoHeight) return;

      const canvas = document.createElement("canvas");
      const w = Math.min(960, v.videoWidth);
      const h = Math.round(w * (v.videoHeight / v.videoWidth));
      canvas.width = w;
      canvas.height = h;

      const ctx = canvas.getContext("2d");
      // espejo frontal
      ctx.translate(w, 0);
      ctx.scale(-1, 1);
      ctx.drawImage(v, 0, 0, w, h);

      lastCamFrame = canvas.toDataURL("image/jpeg", 0.72);
    }

    /*********************
     * FILES
     *********************/
    function updateAtt(){
      el("attCount").textContent = String(attachments.length);
    }

    async function fileToDataUrl(file){
      return new Promise((resolve, reject)=>{
        const fr = new FileReader();
        fr.onload = ()=>resolve(fr.result);
        fr.onerror = reject;
        fr.readAsDataURL(file);
      });
    }

    el("filePick").addEventListener("change", async (ev)=>{
      const files = Array.from(ev.target.files || []);
      for(const f of files){
        // l√≠mite suave para JSON (evitar romper). Si quer√©s, tu backend puede usar multipart.
        if(f.size > 5 * 1024 * 1024){
          sys(`Adjunto demasiado grande (>${5}MB): ${f.name}`);
          continue;
        }
        const dataUrl = await fileToDataUrl(f);
        attachments.push({ name:f.name, type:f.type || "application/octet-stream", size:f.size, dataUrl });
      }
      updateAtt();
      ev.target.value = "";
    });

    /*********************
     * API CALL
     *********************/
    function headers(){
      const h = { "Content-Type":"application/json" };
      if(ownerToken) h["Authorization"] = "Bearer " + ownerToken;
      return h;
    }

    async function callAsk(message){
      const payload = {
        lang: "ES",
        mode: "auto",
        rules: CONSIA_RULES,
        message,
        attachments,
        camera: camOn ? { mode:"live", frame:lastCamFrame } : null,
        realtime: rt.connected ? true : false
      };

      const res = await fetch(API_ASK, { method:"POST", headers: headers(), body: JSON.stringify(payload) });
      let data = null;
      try{ data = await res.json(); }catch(e){}

      if(!res.ok){
        const err = data?.error || data?.message || (res.status + " " + res.statusText);
        throw new Error(err);
      }
      return data;
    }

    async function testApi(){
      try{
        const res = await fetch(API_HEALTH, { method:"GET" });
        const data = await res.json().catch(()=> ({}));
        sys("API OK: " + JSON.stringify(data));
      }catch(e){
        sys("API FAIL: " + String(e.message || e));
      }
    }

    /*********************
     * REALTIME
     *********************/
    function setRealtimeUI(on){
      el("rtText").textContent = on ? "conectado" : "desconectado";
      el("rtText").className = on ? "rtOk" : "rtBad";
    }

    function connectRealtime(){
      // No rompe nada si falla
      try{
        if(rt.ws) rt.ws.close();
        const ws = new WebSocket(RT_WS);
        rt.ws = ws;

        ws.onopen = ()=>{
          rt.connected = true;
          setRealtimeUI(true);
          sys("Realtime conectado.");
        };
        ws.onclose = ()=>{
          rt.connected = false;
          setRealtimeUI(false);
          sys("Realtime desconectado.");
        };
        ws.onerror = ()=>{
          rt.connected = false;
          setRealtimeUI(false);
        };
        ws.onmessage = (ev)=>{
          // si tu backend manda eventos, los mostramos como SYS
          try{
            const obj = JSON.parse(ev.data);
            sys(JSON.stringify(obj));
          }catch(e){
            sys(String(ev.data));
          }
        };
      }catch(e){
        rt.connected = false;
        setRealtimeUI(false);
      }
    }

    /*********************
     * OWNER MODE (token en localStorage; NO lo hardcodeamos)
     *********************/
    function ownerPrompt(){
      const t = prompt("Peg√° tu OWNER token (se guarda solo en este dispositivo):", ownerToken || "");
      if(t === null) return;
      ownerToken = String(t || "").trim();
      if(ownerToken){
        localStorage.setItem("CONSIA_OWNER_TOKEN", ownerToken);
        sys("Owner mode: token guardado en este dispositivo.");
      }else{
        localStorage.removeItem("CONSIA_OWNER_TOKEN");
        sys("Owner mode: token eliminado.");
      }
    }

    async function ownerAvatarTransform(promptText){
      if(!ownerToken){
        sys("Owner requerido.");
        return;
      }
      const payload = { prompt: promptText, rules: CONSIA_RULES, lang:"ES" };
      const res = await fetch(API_AVATAR_TRANSFORM, { method:"POST", headers: headers(), body: JSON.stringify(payload) });
      const data = await res.json().catch(()=> ({}));
      if(!res.ok) throw new Error(data?.error || "transform_fail");
      return data;
    }

    async function refreshAvatarLatest(){
      try{
        const res = await fetch(API_AVATAR_LATEST, { method:"GET", headers: headers() });
        const data = await res.json().catch(()=> ({}));
        // si backend devuelve {url: "..."} la aplicamos
        const url = data?.url;
        if(url){
          const v = el("avatarBase");
          if(v.src !== url){
            v.src = url;
            v.load();
            v.play().catch(()=>{});
          }
        }
      }catch(e){}
    }

    /*********************
     * SEND
     *********************/
    async function sendNow(){
      const text = (msgEl.value || "").trim();
      if(!text) return;

      // ‚Äú.‚Äù como gatillo m√≠nimo
      const isDot = text === ".";

      you(text);
      msgEl.value = "";
      msgEl.style.height = "auto";

      try{
        // Owner short commands
        if(ownerToken && text.toLowerCase().startsWith("avatar:")){
          const p = text.slice(7).trim();
          ai("OK. Actualizando avatar‚Ä¶");
          const out = await ownerAvatarTransform(p);
          ai(out?.reply || "Avatar actualizado.");
          await refreshAvatarLatest();
          return;
        }

        // Normal ask
        const data = await callAsk(isDot ? "CONSIA: ejecut√° modo gu√≠a m√≠nima. Pedime 1 cosa m√≠nima y ejecut√°." : text);

        const reply = data?.reply ?? data?.text ?? data?.message ?? JSON.stringify(data);
        ai(reply);

        // si backend manda audio o sugerencia de voz
        if(data?.speak === true) speak(reply);
        else if(speechOn && (text.toLowerCase().includes("voz") || text.toLowerCase().includes("hablar"))) {
          // auto: si el usuario pide voz, respondemos con voz tambi√©n
          speak(reply);
        }
      }catch(e){
        ai("Error: " + String(e.message || e));
      }finally{
        // adjuntos se consumen en el env√≠o
        attachments = [];
        updateAtt();
      }
    }

    /*********************
     * QUICK ACTIONS
     *********************/
    function setPrompt(p){
      msgEl.value = p;
      msgEl.focus();
    }

    function guide3(){
      setPrompt("Guiame: dame 3 opciones y pedime lo m√≠nimo en 1 sola pregunta. Luego esper√° mi 1 frase y ejecut√°.");
      sendNow();
    }
    function whatCan(){
      setPrompt("¬øQu√© puede hacer CONSIA hoy? List√° funciones reales disponibles (texto/voz/realtime/archivos/c√°mara) y pedime lo m√≠nimo.");
      sendNow();
    }
    function hyper(){
      setPrompt("Hiperrealismo: dame 3 opciones (Imagen/Video/Avatar). Pedime lo m√≠nimo en 1 sola pregunta. Luego esper√° mi 1 frase y ejecut√°.");
      sendNow();
    }
    function ascend(){
      setPrompt("ASCEND: modo ultra. Respuestas cortas, plan inmediato y checklist. Pedime 1 dato m√≠nimo.");
      sendNow();
    }

    /*********************
     * EVENTS
     *********************/
    el("sendBtn").onclick = sendNow;
    el("btnTestApi").onclick = testApi;

    // intro
    el("btnIntroEnter").onclick = ()=> introCard.style.display = "none";
    el("btnIntroExplain").onclick = ()=>{
      introCard.style.display = "none";
      // El speech real en iOS requiere gesto: este click sirve como gesto.
      const text =
        "Hola. Soy CONSIA. Pod√©s hablarme por voz, escribirme o tocar botones. " +
        "Pod√©s subir archivos y activar c√°mara frontal para an√°lisis en vivo. " +
        "Yo te pido una sola cosa m√≠nima y ejecuto. " +
        "Modo Owner: solo Mart√≠n puede crear y mejorar desde la interfaz.";
      sys("Intro: activado.");
      speak(text);
    };

    // chips intro
    el("chipGuide").onclick = guide3;
    el("chipWhatCan").onclick = whatCan;
    el("chipHyper").onclick = hyper;
    el("chipVoice").onclick = ()=>toggleListen();
    el("chipCam").onclick = async ()=>{ camOn ? stopCamera() : await startCamera(); };
    el("chipAscend").onclick = ascend;

    // chips HUD
    el("chipTalk").onclick = ()=>toggleListen();
    el("chipRead").onclick = ()=>{
      speechOn = !speechOn;
      sys("Voz (TTS): " + (speechOn ? "ON" : "OFF"));
      if(!speechOn) stopSpeak();
    };
    el("chipClear").onclick = ()=>{
      logEl.innerHTML = "";
      sys("CONSIA UI HOTFIX activo. Input siempre visible. Idioma ES.");
    };
    el("chipStopVoice").onclick = ()=> stopSpeak();
    el("chipOwner").onclick = ()=> ownerPrompt();

    el("chipCamLive").onclick = async ()=>{
      if(camOn) stopCamera();
      else await startCamera();
    };

    // autosize textarea
    msgEl.addEventListener("input", ()=>{
      msgEl.style.height = "auto";
      msgEl.style.height = Math.min(160, msgEl.scrollHeight) + "px";
    });
    msgEl.addEventListener("keydown", (e)=>{
      if(e.key === "Enter" && !e.shiftKey){
        e.preventDefault();
        sendNow();
      }
    });

    // Tap en fondo = permite audio iOS + tambi√©n oculta intro si quer√©s
    stage.addEventListener("click", ()=>{
      // s√≥lo para ‚Äúdesbloquear‚Äù audio
      try{ el("avatarBase").play().catch(()=>{}); }catch(e){}
    }, { passive:true });

    /*********************
     * STARTUP
     *********************/
    // status
    el("apiHost").textContent = "api.consia.world";
    setRealtimeUI(false);

    // Autoplay fallback: si no reproduce, intentamos sin romper
    const avatar = el("avatarBase");
    avatar.addEventListener("error", ()=> sys("Avatar: no se pudo cargar avatar.mp4 (verific√° que exista en el repo)."));
    avatar.play().catch(()=>{ /* iOS puede bloquear hasta gesto */ });

    // Realtime auto-connect (si existe)
    connectRealtime();

    // Estado Owner
    if(ownerToken){
      sys("Owner token detectado en este dispositivo.");
    }

    // Opcional: refrescar avatar si tu backend lo cambia
    setInterval(()=>refreshAvatarLatest(), 5000);

  </script>
</body>
</html>
